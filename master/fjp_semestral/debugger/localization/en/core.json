{
    "modelStackNegativeError": "Negative index access into stack",
    "modelMaxStackSizeError": "Stack maximum size exceeded",
    "modelBaseSearchError": "The static base search reached the first stack frame and the level is not 0 (level is ",
    "modelNonExistentInstructionError": "Non-existent instruction",
    "modelInstructionOutOfBounds1": "Instruction on index ",
    "modelInstructionOutOfBounds2": " is out of bounds",
    "modelReadInvalidInput": "The value on top of the stack is not in range <0, 255>",
    "modelReadInputEmpty": "Nothing to read from the input",
    "modelFreeBlockNotAllocated1": "No allocated block starts on the address ",
    "modelFreeBlockNotAllocated2": "",
    "modelHeapAccessUndefined1": "Heap access on undefined index ",
    "modelHeapAccessUndefined2": ", heap size = ",
    "modelHeapAccessUnallocated": "Heap access on unallocated address ",
    "modelINTStackLow": "Attempt to lower the stack pointer (SP) to -2",
    "modelINTStackFrameLow": "Attempt to lower the stack pointer (SP) below the current stack frame",
    "modelUnknownOPR": "Unknown OPR operation ",

    "explainerLIT": "Adds value %1 on top of the stack",
    "explainerINT": "Increments the stack pointer by %1",
    "explainerJMP": "Jumps to the instruction %1",
    "explainerJMPErr": "Jumps to the instruction %1, which doesn't exist",
    "explainerJMCNonExistent": "The value on top of the stack is %1, but the jump will lead to a non-existent instruction (%2)",
    "explainerJMCJump": "The value on top of the stack is %1, so jump to instruction %2 will be made",
    "explainerJMCDontJump": "The value on top of the stack is %1, no jump will be made",
    "explainerCALOutOfBoundsInstr": "Instruction %1 does not exist",
    "explainerLevelTooHigh": "The level is too high - static base search would have to go under the first stack frame",
    "explainerCALOk1": "Jumps to instruction %1, creates a stack frame with the following instruction (",
    "explainerCALOk2": "), dynamic base (%2) and static base (%3)",
    "explainerRETEnd": "End of program",
    "explainerRET": "Removes the stack frame, jumps to instruction %1, sets the base to dynamic base %2, SP=%3",
    "explainerLOD1": "Loads the value from level %1 and address %2 of the stack (index ",
    "explainerLOD2": ", value ",
    "explainerLOD3": ") and adds it to the top",
    "explainerSTO": "Saves the value on top of the stack (%1) to level %2 address %3 of the stack (index ",
    "explainerWRIAsciiErr": "The value on top of the stack is not an unsigned byte",
    "explainerWRI": "Prints the value on top of the stack (%1) as ASCII ",
    "explainerREAInputEmpty": "Nothing to read from the input - fill the input, otherwise the execution will fail",
    "explainerREA": "Adds a character from the input to the top of the stack - character ",
    "explainerNEWInvalidArg": "Attempt to allocate %1 heap calls, which is not a valid count - -1 will be added to the top of the stack",
    "explainerNEWNoFreeSpace": "Attempt to allocate %1 heap calls, but no large enough block has been found - -1 will be added to the top of the stack",
    "explainerNEW": "Allocates %1 heap cells from address %2, %2 will be added to the top of the stack",
    "explainerDELError": "Error while deallocating address %1 - out of bounds or not allocated",
    "explainerDEL": "Deallocates %1 heap cells from address %2",
    "explainerLDAOutOfBounds": "Address %1 is out of heap bounds",
    "explainerLDAUnallocated": "Address %1 is not allocated",
    "explainerLDA": "Value from heap address %1 will be added to the top of the stack",
    "explainerSTAUnallocated": "Access on unallocated heap address %1",
    "explainerSTAOutOfBounds": "Access on address which is out of heap bounds",
    "explainerSTA": "Saves the value %1 to address %2 on heap",
    "explainerPST": "Saves the value %1 to level %2 and address %3 of the stack (index %4)",
    "explainerEndNoJump": "The value on top of the stack is %1, no jump will be made and no more instructions are available",
    "explainerEndNoMoreInstructions": "Next instruction does not exist",
    "explainerOPR1": "The value on top of the stack is multiplied by -1 (-1 * %1)",
    "explainerOPR2": "The first two values on top of the stack are added (%2 + %1)",
    "explainerOPR3": "The first two value on top of the stack are subtracted (%2 - %1)",
    "explainerOPR4": "The first two value on top of the stack are multiplied (%2 * %1)",
    "explainerOPR5": "The first two value on top of the stack are divided (%2 / %1)",
    "explainerOPR6": "Modulo of the first two values on top of the stack (%2 mod %1)",
    "explainerOPR7": "'Is-odd' test of the value on top of the stack (%1)",
    "explainerOPR8": "Equality test of the first two values on top of the stack (%2 == %1)",
    "explainerOPR9": "Inequality test of the first two values on top of the stack (%2 != %1)",
    "explainerOPR10": "'Smaller-than' test of the first two values on top of the stack (%2 < %1)",
    "explainerOPR11": "'Greater-or-equal' test of the first two values on top of the stack (%2 >= %1)",
    "explainerOPR12": "'Greater-than' test of the first two values on top of the stack (%2 > %1)",
    "explainerOPR13": "'Smaller-or-equal' test of the first two values on top of the stack (%2 <= %1)",

    "validatorLessThan4": "Row contains more than 4 parameters",
    "validatorMoreThan4": "Row contains less than 4 parameters",
    "validatorIndexInteger": "Index has to be an integer",
    "validatorLevelInteger": "Level (L) has to be an integer",
    "validatorParInteger": "Parameter (A) has to be an integer",
    "validatorUnkInstruction": "Unknown instruction",
    "validatorBadIndex": "Instruction index does not correspond to the row number. Instructions have to be indexed from 0.",
    "validatorNegLevel": "Level cannot be negative",
    "validatorLitLevel": "LIT has to have level 0",
    "validatorOprLevel": "OPR has to have level 0",
    "validatorOprParam": "OPR has to have parameter (A) between 1 a 13",
    "validatorCalParam": "CAL has to jump to address >= 0",
    "validatorJmpLevel": "JMP has to have level 0",
    "validatorJmpParam": "JMP has to have parameter (A) >= 0",
    "validatorJmcLevel": "JMC has to have level 0",
    "validatorJmcParam": "JMC has to have parameter (A) >= 0",
    "validatorIntLevel": "INT has to have level 0",
    "validatorRet": "RET has to have both level and parameter (A) 0",
    "validatorRea": "REA has to have both level and parameter (A) 0",
    "validatorWri": "WRI has to have both level and parameter (A) 0",
    "validatorNew": "NEW has to have both level and parameter (A) 0",
    "validatorDel": "DEL has to have both level and parameter (A) 0",
    "validatorLda": "LDA has to have both level and parameter (A) 0",
    "validatorSta": "STA has to have both level and parameter (A) 0",
    "validatorPld": "PLD has to have both level and parameter (A) 0",
    "validatorPst": "PST has to have both level and parameter (A) 0"
}
